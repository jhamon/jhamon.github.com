# Conway's Game of Life

Conway's Game of Life hold's a special place in my heart.  The first non-trivial program I ever wrote was a simple version of the game implemented in Python, and when I decided to learn Javascript I started by coding up Life.  It makes a great code kata because it is relatively quick and easy to get a basic version going, but also provides a lot of opportunity for experimentation and improvement.</p>

I've now done this several times in javascript, each time learning something new.  My first implementation was to learn basic JS syntax, and the HTML5 canvas API, but the code was pretty terrible by my current standards. A second implementation improved on my seperation of concerns between view rendering and game calculations.  My third implementation was to learn more about event-driven programming with Backbone.js; in the backbone version, each cell was represented as a backbone model listening for changes in all its neighbors. 

My best and most recent iteration on Life uses HTML5 Web Workers, provides a user control panel to play with parameters, and implements several algorithmic improvements.  Instead of visiting every cell once per iteration, I now keep track of a "change list".  Since the only thing that can change a node's status is a change in its number of immediate living neighbors, we need only check the nodes that have changed and the neighbors of a node that changed in the previous iteration.  This is a huge savings after the first few chaotic iterations.

Using web workers is a natural evolution.  Now all the calculations are handled in a background thread and I no longer worry about crashing the tab while testing the limits of how small I can go on the pixel size.





# Confessions 

I call this app confessions because my original vision was for something like fmylife.  Enter your anonymous confession, let people vote and comment on it and laugh at your expense.  The app has many more models and views than any of my other projects as of this writing.

I wrote and tested the numerous Rails models and associations needed to support creation and categorization of confessions, upvoting, downvoting, flagging inappropriate content (inevitable on an anonymous site), commenting, and comment voting/flagging.  A first for me, I set up some custom counter caches for things like upvote/downvote count and number of comments.  I also discovered the awesome Kaminari gem for pagination.  There is a single static view that delivers the Backbone app, and the remaining controller logic implements a pure JSON API that is consumed by the client-side Backbone.js code.  Because of all the moving parts, I wrote unit tests for the models, controllers, and requests with Rspec, Faker, FactoryGirl, and Shoulda. 

Although this was not my first use of Backbone (see AdoptMe.me), I felt like it really stretched my ablities and taught me a lot about how to write a non-trivial single page app.  I wrote client-side validations to prevent saving bogus or blank confessions.  I used caching to display the number of upvotes and downvotes.  I learned how to get jQuery to use DocumentFragments to minimize repaint/reflow on collection renders.  I learned to be as specific as possible when setting up event listeners.  And some of my views have objects for tracking view state, to prevent keeping state in the DOM as the user interacts with the page.

# Adoptme.me: Life lessons from cat memes

When I began Adoptme.me, I knew it was an ambitious project because of the many moving parts involved.  I learned a lot from the process, but it is currently on inedefinite hiatus. You can view the bones live on the web at adoptme.me.  

I originally concieved of the site as a cat meme generator in the same vein as icanhascheezburger, but with a social mission of bringing visibility to cats languishing in animal shelters. I thought that if a person is going to spend their time making funny captions for cat images and sharing them around, they might as well give the visibility to a cat that needs it.  

The technical vision was that I would pull images and data from the free petfinder.com API, push them into my amazon S3 bucket, let users caption them with a canvas-based javascript editor, and then send the resulting image off to my Amazon S3 bucket.  The image would be watermarked with a generated shortlink that viewers of the image could follow to learn more about how to adopt that animal.

Since I was already familiar with HTML5 Canvas and the basics of APIs I felt like it was doable, and I first wrote a rake task to pull images and content from the petfinder.com API and push them into my Amazon S3 bucket.  The petfinder data is user-generated so I had to write some code to clean their responses.  Next I coded an MVP version of the canvas-based meme editor that overlays text as you type.  I wrote the shortlink and watermarking logic, and was nearing the last piece of the MVP puzzle: uploading my newly captioned images.  It is at that moment that I ran head-on into a Same-Origin security error.  I learned, painfully, that the browser's Same-Origin Policy was not going to let me save any of my users meme images directly to S3 because the background cat image was not coming from the same origin as the page I was serving from heroku.  What I thought was going to be as easy as a call to .toDataURL ended up being a much bigger problem.

I fiddled with server side generation of the captioned images using imagemagick via the rmagick gem.  I actually got this to work and its what you will experience if you try to use the live version of the site, but I knew that blocking my rails application with image processing jobs was going to be unacceptably slow with more than one or two concurrent users.  The image work wasn't a candidate to be a deffered job because the user is waiting to see their creation.  

The whole thing seemed unsalvageable at that point so I put the project on hold while I kept learning and working on other things.  Since then I've learned that what I originally intended may be possible with CORS, Cross-Origin Resource Sharing, but I haven't yet gotten back to the project.

# jlh.io: My very own linkshortner

I created this Backbone/Rails app because sometimes it's nice to have shortlinks, but I wanted to retain control of my links rather than routing them through a third-party service I have no control over.  In it's present form, it only has one user-facing feature: enter a URL and recieve back a valid shortlink.  I have implemented the backend to log traffic information, so I could compute and show analytics on a per-site and per-user basis if I ever get around to it.  But the site serves my present needs just fine in its present form.

# Serpent.io: Event-driven programming, with snakes.

When I first wrote this game I was still learning the "javascript way" of doing object-oriented programming with prototypical inheritance.  I more or less succeeded in that aspect, but the code responsible for rendering the view and managing user interactions was a huge ball of mud.  At that time I knew just enough jQuery to be dangerous, and while the basic mechanics seemed to work I had all my truth in the DOM and ran into a wall while trying to extend it to have more features.  I wasn't unbinding events properly, so chaos ensued when I tried to reset the game for another play without a hard refresh.  It was a mess, but I had other things I wanted to work on.

I recently revisted the project for a couple of days to apply what I'd learned in the intervening months about keeping a clean seperation between the DOM and my data with the help of a client-side framework called Backbone.js.  I did an almost complete rewrite, and instead of iterating over all the cells for every frame the game is now primarily driven by cascading events.  The cell is the fundamental model of the game, which may belong to any of several different collections (snakeSegments, apples, obstacles) depending on the current state of that cell; these collections publish appropriate events when cells are added or removed, which trigger changes elsewhere in the game.  For example, when an apple is eaten the game view hears the "appleEaten" event and knows to update the score and make a new apple.

Each square on the screen is linked to a cell view.  The view listens to change events on the cell model and changes it's css class when the underlying model changes.

As a finishing touch, I whipped up a simple Ruby on Rails backend to allow users to save scores to a scoreboard.