---
layout: post
title: "Blocks, Procs, and Lamdas: A Tour of Anonymous Functions in Ruby"
date: 2013-9-10 12:27:47 -0700
comments: true
categories: ruby
---

Great news! Ruby has several ways of creating and passing around anonymous functions.  Key language features like the `Enumerable` module would not be possible without this capability.

You might not even realize that when you are using a function that takes a block, you have just written an anonymous function. An anonymous function is exactly what it sounds like: a function with no name.

```ruby
  %w(do re mi fa so la ti).map! { |note| note.capitalize }
  # => ["Do", "Re", "Mi", "Fa", "So", "La", "Ti"]
```

In this example, the `{ |note| note.capitalize }` bit is the anonymous function. Used in this way the `{}` characters are block literals, passing function expecting one variable to the higher-order `map!` method.

## Our own methods that take blocks

We can pretty easily write our own methods that accept blocks like this.

```ruby
def block_caller(&block)
  puts "Hello from inside block_caller"
  block.call
  puts "About to leave block_caller"
end
```

Which we can use like this


```ruby
block_caller do
  puts "Hello from inside the block"
end
# Hello from inside block_caller
# Hello from inside the block
# About to leave block_caller
# => nil
```

We use blocks expecting an argument in a very similar way.

```ruby
def greeting(name, &block)
    block.call(name)
end

greeting("Mao")      { |name| "Ni hao, #{name}!"}
# => "Ni hao, Mao!"
greeting("Adolf")    { |name| "Guten Tag, #{name}!"}
# => "Guten Tag, Adolf!"
```

## Use `yield` for a nice performance boost

There's an alternative syntax available to us when writing methods expecting blocks: the `yield` keyword.  We should prefer it because benchmarking shows that `yield` is about 5x faster than `block.call`.

```ruby
def greeting(name)
    yield name
end

greeting("Mao")      { |name| "Ni hao, #{name}!"}
# => "Ni hao, Mao!"
greeting("Adolf")    { |name| "Guten Tag, #{name}!"}
# => "Guten Tag, Adolf!"
```


## Overcoming limitations of blocks with Proc

If you do a little experimentation, you might notice that this brace syntax is a syntactic sugar that can only be used after a method call.

```ruby
[2] pry(main)> { |note| note.capitalize }
SyntaxError: unexpected '}', expecting end-of-input
```

There's also no way to pass multiple blocks to a single function.  So a very common idiom in other langauges like JavaScript is to pass multiple functions to be used in different circumstances.  For example, when making an Ajax call it's convenient to pass both a success and error callback so our code knows how to continue in both situations:

```javascript
// example.js

function successCallback() {
  // Take care of business
}
function errorCallback() {
  // Do damage control
}

$.ajax({
  url: 'http://www.example.com/api/widgets',
  type: 'GET',
  success: successCallback,
  error: errorCallback
})
```

The equivalent ruby would be something like

```ruby
def ajax(url, type, success, error)
  # ... where the magic happens
end
```

We can't use blocks to send `success` and `error` callbacks to this method. To accomplish this type of feat with Ruby, we have to use `Proc` objects, which Ruby provides as a way of wrapping a block into an object that may be passed around and used in multiple places. This is useful to use because methods can accept an arbitrary number of object parameters.

The simplest possible example of a `Proc` would be something like this:

```ruby
  capitalizer = Proc.new { |str| str.capitalize }
  capitalizer.call("obama") # => "Obama"
```

Using `Proc` and keeping in mind that blocks are closures, we can write functions that return Procs.

```ruby
def make_counter()
  x = 0
  Proc.new { x += 1 }
end


counter = make_counter()
counter.call() # => 1
counter.call() # => 2
counter.call() # => 3
```

## Using a proc where a block is expected

If we need to use a proc where a block is expected, we can use the `&` operator.

```ruby
add_five = Proc.new { |x| x + 5 }
[1, 2, 3, 4].map &add_five
# => [6, 7, 8, 9]
```

## Choose your own syntax

Because Ruby likes to have multiple ways to accomplish everything, we've got several different sytnaxes available to us for constructing `Proc` objects.

```ruby
  # Create a Proc object directly
  Proc.new  { |x, y| x + y }

  # Use this Kernal method
  proc      { |x, y| x + y }

  # Or this Kernal method
  lambda    { |x, y| x + y }

  # Or the "stabby lambda" syntax
  -> (x, y) { x + y }
```

The Proc methods and lambda methods are almost exactly the same except for the [strange way](http://stackoverflow.com/questions/626/when-to-use-lambda-when-to-use-proc-new) the `return` keyword is handled in procs created with `Proc.new`.

The "stabby lambda" syntax, though probably the ugliest of all, can do something that none of the others can and that is specify default parameters similar to a normal method declaration.

```ruby
adder = -> (x=5, y=4) { x + y }
adder.call() # => 9
```

Handy!

## Gimme that method

One final trick to have up your sleeve it the ability to reach inside an object and turn any method into a `Proc`.

```ruby
class Pig
  def oink
    puts "Oink!"
  end
end

wilbur = Pig.new
oinker = wilbur.method(:oink).to_proc
oinker.call
# Oink!
# => nil
```

## Summary

Amazing! That concludes the tour of ruby's blocks, procs, and lambdas.

To summarize:

- Use blocks for one-off inline anonymous functions.
- Use `Proc.new` if you need to reuse a code multiple times or need to pass multiple functions as arguments to the same function.
- Use `->` if you want to specify default parameters for your anonymous function.
